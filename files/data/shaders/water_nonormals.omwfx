uniform_float uRange {
    default = 2.0;
    min = 0.01;
    max = 4.0;
    step = 0.05;
    description = "What fraction of the screen the raymarcher is willing to cover.";
    display_name = "Range";
}
uniform_float uSmoothness {
    default = 0.5;
    min = 0.0;
    max = 1.0;
    step = 0.05;
    description = "Smoothness of water normals.";
    display_name = "Smoothness";
}
uniform_int uSteps {
    default = 16;
    min = 3;
    max = 256;
    step = 1;
    description = "Number of steps the raymarcher takes. BIG impact on performance.";
    display_name = "Steps";
}
uniform_int uGranularIterations {
    default = 1;
    min = 0;
    max = 3;
    step = 1;
    description = "Number of extra times to run the raymarching algorithm. Impacts performance.";
    display_name = "Refinement Runs";
}
uniform_float uGamma {
    default = 2.2;
    min = 0.1;
    max = 4.0;
    step = 0.05;
    description = "Gamma compression.";
    display_name = "Gamma";
}
uniform_float uThickness {
    default = 100.0;
    min = 0.0;
    max = 10000.0;
    step = 10.0;
    description = "Far comparison thickness.";
    display_name = "Thickness";
}
uniform_bool uLinearEstimate {
    default = true;
    description = "Whether to do hit coordinate estimation interpolation.";
    display_name = "Linear contact estimation";
}
uniform_bool uScreenEdgeHack {
    default = true;
    description = "Change how the screen edge is handled.";
    display_name = "Screen Edge Hack";
}
uniform_bool uUseStepcountNoise {
    default = true;
    description = "Add a noise effect that makes different spots hit slightly different locations in 3d space.";
    display_name = "Use Stepcount Noise";
}
uniform_float uRefraction {
    default = 0.25;
    min = 0.0;
    max = 1.0;
    step = 0.01;
    description = "Whether to do refraction. Almost free!";
    display_name = "Refraction";
}
uniform_bool uUnderwaterFog {
    default = true;
    description = "Whether to add fog when looking underwater from above water.";
    display_name = "Underwater Fog";
}
uniform_float uDemoHack {
    default = 0.5;
    min = 0.0;
    max = 1.0;
    step = 0.05;
    description = "Hack reflections and refractions for demonstration.";
    display_name = "Demo Hack";
}
uniform_float uSkyBlendEstimation {
    default = 0.5;
    min = 0.0;
    max = 1.0;
    step = 0.05;
    description = "Hack for people using sky blending. 0 to disable.";
    display_name = "Sky Blending Hack";
}
uniform_float uSunRadius {
    default = 0.5;
    min = 0.0;
    max = 10.0;
    step = 0.05;
    description = "...";
    display_name = "Sun Radius";
}
uniform_float uSunBrightness {
    default = 1000.0;
    min = 0.0;
    max = 10000.0;
    step = 100.0;
    description = "...";
    display_name = "Sun Brightness";
}
uniform_float uSunRoughness {
    default = 0.01;
    min = 0.001;
    max = 1.0;
    step = 0.001;
    description = "...";
    display_name = "Sun Roughness";
}

sampler_2d normalMap {
    source = "shaders/water_nm.png";
    mag_filter = linear;
    min_filter = linear;
    wrap_s = repeat;
    wrap_t = repeat;
}

fragment main
{
    #define PI 3.1415926535

    float fresnelSchlick(float incidence, float f0, float f90)
    {
        float t = clamp(1.0 - incidence, 0.0, 1.0);
        float t2 = t*t;
        float t5 = t2*t2*t;
        return mix(f0, f90, t5);
    }
    float distGGX(float halfIncidence, float r)
    {
        r = r*r;
        r = r*r;
        
        float d = halfIncidence*halfIncidence * (r - 1.0) + 1.0;
        
        return r / (d * d * PI);
    }
    float geoSchlickGGX(float incidence, float roughness)
    {
        roughness += 1.0;
        float k = (roughness * roughness) / 8.0;
        return incidence / mix(incidence, 1.0, k);
    }
    float geoSmith(float viewIncidence, float lightIncidence, float roughness)
    {
        return geoSchlickGGX(viewIncidence, roughness) * geoSchlickGGX(lightIncidence, roughness);
    }
    float BRDF(vec3 normalDir, vec3 viewDir, vec3 lightDir, vec3 halfDir, float roughness)
    {
        float lightIncidence = max(dot(normalDir, lightDir), 0.00001);
        float halfIncidence  = max(dot(normalDir,  halfDir), 0.00001);
        float viewIncidence  = max(dot(normalDir,  viewDir), 0.00001);
        
        float NDF = distGGX(halfIncidence, roughness);
        float geo = geoSmith(viewIncidence, lightIncidence, roughness);
        
        return (NDF * geo) / (4.0 * viewIncidence * lightIncidence);
    }
    
    float getPBRSpecular(vec3 normal, vec3 viewDir, vec3 lightPos, float roughness)
    {
        vec3 lightDir = normalize(lightPos);
        
        vec3 reflected = reflect(-viewDir, normal);
        float angle = acos(dot(reflected, lightDir));
        if (angle < uSunRadius * PI / 180.0)
            lightDir = reflected;
        else
        {
            // approximation of rotating the lightdir vector towards the point of reflection by the light's radius (0.5deg)
            float m = sin(uSunRadius * PI / 180.0);
            vec3 n = normalize(reflected - lightDir);
            lightDir = normalize(lightDir + n * m);
        }
        
        vec3 normalDir = normal;
        vec3 halfDir = normalize(viewDir + lightDir);
        
        float baseIncidence = dot(normalDir, lightDir);
        
        float fresnel = fresnelSchlick(max(dot(halfDir, viewDir), 0.0), 0.02, 1.0);
        float specular = BRDF(normalDir, viewDir, lightDir, halfDir, roughness);
        
        float eyeCosine = dot(-viewDir, normalDir);
        if (baseIncidence < 0.0)
        {
            baseIncidence = -baseIncidence;
            eyeCosine = -eyeCosine;
        }
        baseIncidence *= clamp(-8.0 * (1.0 - 0.3) * eyeCosine + 1.0, 0.3, 1.0);

        // reduce specularity by incidence against plane normal to conserve energy
        specular *= baseIncidence;
        
        return specular * fresnel;
    }

    int maxi(int a, int b)
    {
        return a > b ? a : b;
    }
    
    omw_In vec2 omw_TexCoord;
    
    
    float unlerp(float x, float low, float high)
    {
        return (x-low)/(high-low);
    }
    
    float fogDepth(float depth, vec3 viewDir)
    {
#if OMW_RADIAL_FOG
        depth /= abs(viewDir.z);
#endif
        return depth;
    }
    float fogDepthToFog(float depth)
    {
#if OMW_EXPONENTIAL_FOG
        float x = max(0.0, unlerp(depth, omw.fogNear/2.0, omw.fogFar));
        float fogAmount = 1.0 - exp(-2.0 * x);
#else
        float fogAmount = clamp(unlerp(depth, omw.fogNear, omw.fogFar), 0.0, 1.0);
#endif
        return fogAmount;
    }
    float fogSkyFadeContrib(float depth)
    {  
        if (uSkyBlendEstimation > 0.0)
        {
            //float fadeValue = clamp((omw.far - depth) / (omw.far - omw.far*0.5), 0.0, 1.0);
            float fadeValue = clamp(unlerp(omw.far - depth, 0.0, omw.far*uSkyBlendEstimation), 0.0, 1.0);
            fadeValue *= fadeValue;
            return 1.0-fadeValue;
        }
        else
            return 0.0;
    }
    float depthToFog(float depth, vec3 viewDir)
    {
        float fogAdjustedDepth = fogDepth(depth, viewDir);
        return mix(fogDepthToFog(fogAdjustedDepth), 1.0, fogSkyFadeContrib(fogAdjustedDepth));
    }
    
    
    float smoothstep(float x)
    {
        x = clamp(x, 0.0, 1.0);
        return -2.0*x*x*x + 3.0*x*x;
    }
    
    struct RaymarchOutput
    {
        vec2 coord;
        vec4 color;
    };
    
    float scramblify(float x)
    {
        x = fract(x);
        x = x + 4.0;
        x = x*x;
        x = x*x;
        return fract(x);
    }
    float scramblev2_inner(vec2 v, float z)
    {
        return scramblify(v.x*0.6491 + v.y*0.029 + z);
    }

    RaymarchOutput raymarch(vec3 water_pos, float water_distance, vec3 normal, vec3 reflected, vec2 res)
    {
        vec3 reflected_view = (omw.viewMatrix * vec4(reflected, 0.0)).xyz;
        
        float final_depth = water_distance;
        
        float closest_penetration = -omw.far;
        bool any_hit = false;
        float last_non_sky_i = 0.0;
        float closest_i = 0.0;
        
        int stepcount = uSteps;
        //float world_distance = 1000.0;
        float world_distance = reflected_view.z < 0.0 ? min(50000.0, omw.far*2.0) : (water_distance / reflected_view.z * 0.99);
        // as fraction of screen height (if I'm dividing/multiplying by the right values)
        float screen_distance = uRange;
        
        vec4 startpos_view = omw.viewMatrix * vec4(water_pos, 1.0);
        vec4 startpoint = omw.projectionMatrix * startpos_view;
        startpoint.xy = (startpoint.xy/startpoint.w);
        
        vec4 endpos_view = omw.viewMatrix * vec4(water_pos + reflected*world_distance, 1.0);
        vec4 endpoint = omw.projectionMatrix * endpos_view;
        endpoint.xy = (endpoint.xy/endpoint.w);
        
        vec2 endpoint_clamped = endpoint.xy;
        if(true)
        {
            endpoint_clamped.xy -= startpoint.xy;
            endpoint_clamped.x *= res.x/res.y;
            
            float len = length(endpoint_clamped.xy);
            if(len > screen_distance*2.0)
                endpoint_clamped.xy *= screen_distance*2.0/len;
            
            endpoint_clamped.x /= res.x/res.y;
            endpoint_clamped.xy += startpoint.xy;
        }
        
        float reduction = length(endpoint_clamped.xy - startpoint.xy) / length(endpoint.xy - startpoint.xy);
        endpos_view = (startpos_view * endpos_view) / mix(endpos_view.z, startpos_view.z, reduction);
        
        float real_world_distance = length(endpos_view.xyz - startpos_view.xyz);
        
        startpoint.xy = startpoint.xy * 0.5 + 0.5;
        endpoint_clamped.xy = endpoint_clamped.xy*0.5 + 0.5;
        
        float start_depth = omw_GetLinearDepth(startpoint.xy);
        float end_depth = omw_GetLinearDepth(endpoint_clamped.xy);
        bool end_is_sky = end_depth == omw.far;
        
        float mid_depth = omw_GetLinearDepth(mix(startpoint.xy, endpoint_clamped.xy, 0.75));
        bool mid_is_sky = mid_depth == omw.far;
        
        //vec3 sample = vec3(-1.0);
        vec2 sample_coord = vec2(0.0);
        float sample_penetration = 0.0;
        vec2 origin = omw_TexCoord;
        
        vec2 step = (endpoint_clamped.xy - startpoint.xy) / float(stepcount);
        
     //   float max_i = 0;
        float sampled_i = 0.0;
        float jspan = 1.0;
        
        vec2 maybe_maybe_coord = vec2(0.0);
        
        bool hit_backside = false;
        
        for(int j = 0; j < uGranularIterations+1; j += 1)
        {
            //float start_i = min(sampled_i, last_non_sky_i) - jspan;
            float start_i = sampled_i - jspan;
            float end_i = start_i + jspan * 2.0;
            if (!any_hit || final_depth == omw.far || closest_penetration > -0.05)
            {
                start_i = closest_i - jspan;
                end_i = closest_i + jspan;
            }
            float start = max(0.0, start_i);
            float end = (j == 0) ? float(stepcount) : min(float(stepcount), end_i);
            float modifier = (j == 0) ? 1.0 : float(end - start)/float(stepcount);
            if (j > 0)
                jspan /= float(stepcount);
            
            //vec3 prev_sample = vec3(-1.0);
            vec2 prev_sample_coord = origin + step*start;
            float prev_sample_penetration = 0.0;
            bool prev_hit = false;
            float prev_depth = 0.0;
            float prev_expected_depth = 0.0;
            
            int allow_skip_depth = 0;
            
            for (int i = 0; i <= stepcount; i += 1)
            {
                float t = float(start)/float(stepcount) + float(i)/float(stepcount)*modifier;
                if (uUseStepcountNoise && (j != 0 || (i != 0 && i != stepcount)))
                    //t = mix(t, 1.0/float(stepcount), scramblev2_inner(water_pos.xy, fract(omw.simulationTime))*(1.0-t)*t*2.0);
                    t += (scramblev2_inner(water_pos.xy, fract(omw.simulationTime)) - 0.5) * modifier*(1.0/float(stepcount));
                vec2 coord = origin + step*t*float(stepcount);
                
                // prevent smudging of hit object borders
                coord = floor(coord/res)*res + res*0.5;
                
                float depth = omw_GetLinearDepth(coord);
                
                // depth-weighted linear interpolation (perspective correct)
                float expected_depth = min(omw.far, (-startpos_view.z * -endpos_view.z) / mix(-endpos_view.z, -startpos_view.z, t));
                float penetration = expected_depth - depth;
                
                if (depth != omw.far)
                    last_non_sky_i = float(i);
                if (j == 0 && penetration/expected_depth > closest_penetration && depth != omw.far && penetration <= 0.0)
                {
                    closest_i = t*float(stepcount);
                    closest_penetration = penetration/expected_depth;
                }
                // we hit something
                if (penetration >= 0.0)
                {
                    if (depth != omw.far && (depth > water_distance || (penetration < uThickness && depth > uThickness)))
                        maybe_maybe_coord = coord;
                    // if hit is in foreground relative to water, allow the raytracer to pretend the stuff behind it is empty
                    if (allow_skip_depth == 0)
                    {
                        if (depth > water_distance)
                            allow_skip_depth = 1;
                    }
                    if (allow_skip_depth == 1 && !prev_hit)
                    {
                        if (depth + (depth - prev_depth) + uThickness < water_distance)
                            allow_skip_depth = 2;
                    }
                    
                    if (
                        !prev_hit && (
                        sample_coord == vec2(0.0)
                        || (j == 0 && penetration > sample_penetration + uThickness)
                        || j > 0
                        )
                        && (depth > water_distance || penetration - water_distance + uThickness < prev_sample_penetration)
                        )
                    {
                        sample_penetration = penetration;
                        
                        // bypass if coming from behind object, or thickness test passes and nearer than previous step
                        if (prev_hit || depth == omw.far || (expected_depth < depth + uThickness && depth + uThickness < prev_depth))
                        {
                            //sample = omw_GetLastShader(coord).rgb;
                            sample_coord = coord;
                            sampled_i = t*float(stepcount);
                        }
                        // estimation of sample coordinate, unless previous step was further away
                        //else if (uLinearEstimate && prev_depth < depth + uThickness)
                        else if (i != 0 && uLinearEstimate && prev_depth < depth + uThickness)
                        {
                            float p = abs(prev_sample_penetration) / (penetration + abs(prev_sample_penetration));
                            float e = min(penetration, (prev_sample_penetration * penetration) / mix(-penetration, -prev_sample_penetration, 0.0));
                            //penetration = sqrt(penetration);
                            //float p2 = mix(prev_sample_penetration, penetration, 0.0);
                            //float p2 = abs(prev_sample_penetration) / (penetration + abs(prev_sample_penetration));
                            float p2 = abs(prev_sample_penetration) / (e + abs(prev_sample_penetration));
                            sample_coord = mix(prev_sample_coord, coord, p2);
                            sampled_i = t*float(stepcount) - modifier + p2*modifier;
                            sample_penetration = p2;
                        }
                        else
                        {
                            // for proper search
                            //if (true)//depth > water_distance - 1.0)
                            //if (allow_skip_depth != 0)
                            //if (false)
                            //if (true)
                            //if (depth != omw.far && depth > water_distance)
                            //if (depth == omw.far)
                            
                            vec3 sdiff = normalize(omw_GetWorldPosFromUV(prev_sample_coord) - water_pos);
                            vec3 sdiff2 = normalize(omw_GetWorldPosFromUV(sample_coord) - water_pos);
                            
                            if (i != 0 && (depth > water_distance || dot(sdiff, normal) >= -0.05))
                            {
                                if (j != uGranularIterations || prev_depth > water_distance)
                                {
                                    sample_coord = prev_sample_coord;
                                    sampled_i = t*float(stepcount) - modifier;
                                }
                                else
                                {
                                    sample_coord = coord;
                                    sampled_i = t*float(stepcount);
                                }
                            }
                        }
                        
                        final_depth = depth;
                        prev_hit = false;
                        if (allow_skip_depth == 1)
                            break;
                    }
                    prev_hit = true;
                }
                else
                    prev_hit = false;
                
                any_hit = true;
                prev_sample_coord = coord;
                prev_sample_penetration = penetration;
                prev_depth = depth;
                prev_expected_depth = expected_depth;
                
                bool cond = coord.y < 0.0 || coord.y > 1.0;
                if (!uScreenEdgeHack)
                    cond = cond || coord.x < 0.0 || coord.x > 1.0;
                if (cond)
                    break;
                
            //    max_i = max(max_i, i);
            }
        }
        
        //bool no_sample = sample_penetration == 0.0 && sample_coord == vec2(0.0);
        bool no_sample = sample_coord == vec2(0.0);
        
        float sample_depth = omw_GetLinearDepth(sample_coord);
        // see through to sky if never hit anything and if endpoint was also sky
        if ((no_sample || sample_depth == omw.far) && end_is_sky)
            sample_coord = endpoint_clamped.xy;
        else if (no_sample && maybe_maybe_coord != vec2(0.0))
            sample_coord = maybe_maybe_coord;
        else if (no_sample && omw_GetLinearDepth(endpoint_clamped.xy + vec2(0.05,0.0)) > water_distance && omw_GetLinearDepth(endpoint_clamped.xy + vec2(0.05,0.0)) != omw.far)
            sample_coord = endpoint_clamped.xy + vec2(0.05,0.0);
        else if (no_sample && omw_GetLinearDepth(endpoint_clamped.xy - vec2(0.05,0.0)) > water_distance && omw_GetLinearDepth(endpoint_clamped.xy - vec2(0.05,0.0)) != omw.far)
            sample_coord = endpoint_clamped.xy - vec2(0.05,0.0);
        else if (no_sample)
        {
            RaymarchOutput ret;
            ret.coord = vec2(0.0);
            ret.color = vec4(vec3(-1.0), 0.0);
            return ret;
        }
        
        sample_coord = floor(sample_coord/res)*res + res*0.5;

        vec3 sample = omw_GetLastShader(sample_coord).rgb;
        vec4 world_color = vec4(vec3(-1.0), 1.0);
        
        // apply world with fringe alpha at edges
        if (true)
        {
            float px_dist = length((sample_coord - omw_TexCoord)/res);
            float n0 = clamp((1.0 - (px_dist / screen_distance)*res.y) * 4.0, 0.0, 1.0);
            
            //float offset = 1000.0;
            //float f = 1.0/(offset*offset)*1000.0;
            //f = clamp(f, 0.0, 1.0);
            float f = 0.0001;
            
            float gauge = 3.0;
            gauge = mix(1.0, 50.0, sqrt(f));
            
            vec2 clip = max(vec2(0.0), abs(sample_coord*2.0-1.0)*gauge - gauge + 1.0);
            
            float a_x = uScreenEdgeHack ? 1.0 : (1.0-pow(clip.x, 4.0));
            float y_adjust = max(abs(omw_TexCoord.y-0.5)-0.3, 0.0)*10.0 + 1.0;
            float a_y = clamp(mix(0.0, 3.0*y_adjust, 1.0 - clip.y), 0.0, 1.0);
            float a = a_x*a_y*n0;
            a = clamp(a, 0.0, 1.0);
            a = 1.0-pow(1.0-a, uGamma);
            
            world_color = vec4(pow(sample, vec3(uGamma)), a);
        }
        
        RaymarchOutput ret;
        ret.coord = sample_coord;
        ret.color = world_color;
        //ret.color.rg = sample_coord.xy;
        //ret.color.rg = endpoint_clamped.xy-0.5;
        //ret.color.rg = startpoint.xy*0.5-0.5;
        //ret.color.rg = pow(ret.color.rg, vec2(2.0));
        //ret.color.b = 1.0;
        //ret.color.a = 1.0;
        return ret;
    }

    const vec2 BIG_WAVES = vec2(0.1, 0.1); // strength of big waves
    const vec2 MID_WAVES = vec2(0.1, 0.1); // strength of middle sized waves
    const vec2 MID_WAVES_RAIN = vec2(0.2, 0.2);
    const vec2 SMALL_WAVES = vec2(0.1, 0.1); // strength of small waves
    const vec2 SMALL_WAVES_RAIN = vec2(0.3, 0.3);
    const float WAVE_CHOPPYNESS = 0.05;                // wave choppyness
    const float WAVE_SCALE = 75.0;                     // overall wave scale
    const float BUMP = 0.5;                            // overall water surface bumpiness
    const float BUMP_RAIN = 2.5;
    const vec2 WIND_DIR = vec2(0.5f, -0.8f);
    const float WIND_SPEED = 0.2f;

    vec2 normalCoords(vec2 uv, float scale, float speed, float time, float timer1, float timer2, vec3 previousNormal)
    {
        return uv * (WAVE_SCALE * scale) + WIND_DIR * time * (WIND_SPEED * speed) -(previousNormal.xy/previousNormal.zz) * WAVE_CHOPPYNESS + vec2(time * timer1,time * timer2);
    }

    uniform sampler2D omw_SamplerRippleMap;
    uniform float worldScaleFactor;
    uniform float RTTSize;
    uniform float rainIntensity;
    uniform vec3 nodePosition;

    void main()
    {
        float gamma = uGamma;
        
        vec2 res = omw.rcpResolution.xy;
        
        vec3 base_color_raw = omw_GetLastShader(omw_TexCoord).rgb;
        vec3 sun_color_raw = omw.sunColor.rgb;
        
        vec3 fog_color_raw = omw.fogColor.rgb;
        
        //vec3 ambient_color_raw = omw.ambientColor.rgb;
        vec3 ambient_color_raw = vec3(0.5);
        
        vec3 base_color = pow(base_color_raw, vec3(gamma));
        vec3 sun_color = pow(sun_color_raw, vec3(gamma));
        vec3 fog_color = pow(fog_color_raw, vec3(gamma));
        vec3 ambient_color = pow(ambient_color_raw, vec3(gamma));
        
        
        vec3 world_pos = omw_GetWorldPosFromUV(omw_TexCoord);
        bool cam_above = omw.eyePos.z >= omw.waterHeight;
        bool frag_above = world_pos.z >= omw.waterHeight;
        
        float sunvis = omw.sunVis;
        
        if (cam_above != frag_above && omw.isWaterEnabled)
        {
            float water_plane_fraction = abs(omw.eyePos.z - omw.waterHeight) / abs(omw.eyePos.z - world_pos.z);
            float underwater_distance = omw_GetLinearDepth(omw_TexCoord);
            float water_distance = water_plane_fraction * underwater_distance;
            
            float filter_amount = 1.0;
            
            vec3 view_ray = normalize(world_pos - omw.eyePos.xyz);
            vec3 view_ray_view = (omw.viewMatrix * vec4(view_ray, 0.0)).xyz;

            vec3 view_normal = vec3(0.0);

//            if (world_pos.z <= 0.0)
            {
                #define waterTimer omw.simulationTime

                vec2 UV = mix(omw.eyePos.xyz, world_pos, water_distance/underwater_distance).xy / (8192.0*5.0) * 3.0;

                vec3 normal0 = 2.0 * texture2D(normalMap,normalCoords(UV, 0.05, 0.04, waterTimer, -0.015, -0.005, vec3(0))).rgb - 1.0;
                vec3 normal1 = 2.0 * texture2D(normalMap,normalCoords(UV, 0.1,  0.08, waterTimer,  0.02,   0.015, normal0)).rgb - 1.0;
                vec3 normal2 = 2.0 * texture2D(normalMap,normalCoords(UV, 0.25, 0.07, waterTimer, -0.04,  -0.03,  normal1)).rgb - 1.0;
                vec3 normal3 = 2.0 * texture2D(normalMap,normalCoords(UV, 0.5,  0.09, waterTimer,  0.03,   0.04,  normal2)).rgb - 1.0;
                vec3 normal4 = 2.0 * texture2D(normalMap,normalCoords(UV, 1.0,  0.4,  waterTimer, -0.02,   0.1,   normal3)).rgb - 1.0;
                vec3 normal5 = 2.0 * texture2D(normalMap,normalCoords(UV, 2.0,  0.7,  waterTimer,  0.1,   -0.06,  normal4)).rgb - 1.0;

                vec4 rainRipple;

                if (rainIntensity > 0.01/* && enableRainRipples*/)
                    rainRipple = rainCombined(mix(omw.eyePos.xyz, world_pos, water_distance/underwater_distance).xy/1000.0, waterTimer) * clamp(rainIntensity, 0.0, 1.0);
                else
                    rainRipple = vec4(0.0);

                vec3 rippleAdd = rainRipple.xyz * 10.0;
#if 1
                vec2 rippleMapUV = (world_pos.xy - omw.eyePos.xy + (RTTSize * worldScaleFactor / 2.0)) / RTTSize / worldScaleFactor;

                float distToCenter = length(rippleMapUV - vec2(0.5));
                float blendClose = smoothstep(0.001, 0.02, distToCenter);
                float blendFar = 1.0 - smoothstep(0.3, 0.4, distToCenter);
                float distortionLevel = 2.0;
                rippleAdd += distortionLevel * vec3(texture2D(omw_SamplerRippleMap, rippleMapUV).ba * blendFar * blendClose, 0.0);
#endif
                vec2 bigWaves = BIG_WAVES;
                vec2 midWaves = mix(MID_WAVES, MID_WAVES_RAIN, rainIntensity);
                vec2 smallWaves = mix(SMALL_WAVES, SMALL_WAVES_RAIN, rainIntensity);
                float bump = mix(BUMP,BUMP_RAIN,rainIntensity);

                vec3 normal = (normal0 * bigWaves.x + normal1 * bigWaves.y + normal2 * midWaves.x +
                   normal3 * midWaves.y + normal4 * smallWaves.x + normal5 * smallWaves.y + rippleAdd);
                normal = normalize(vec3(-normal.x * bump, -normal.y * bump, normal.z));

                normal = (omw.viewMatrix * vec4(normal, 0.0)).xyz;

                view_normal = normal;
            }

            // normals from water shader are too strong, make them weaker
            vec3 view_up = (omw.viewMatrix * vec4(0.0, 0.0, 1.0, 0.0)).xyz;
            view_normal = normalize(mix(view_normal, view_up, uSmoothness));
            
            vec4 worldsun = omw.sunPos;
            if (worldsun.z < 0.0)
            {
                worldsun.z = -worldsun.z;
                filter_amount *= 0.25;
            }
            vec3 sun = normalize(worldsun.xyz);//normalize((omw.viewMatrix * -worldsun).xyz);
            vec3 normal = normalize((omw.invViewMatrix * vec4(view_normal, 0.0)).xyz);
            
            vec3 reflected = normalize(reflect(view_ray, normal));
            
            if (!cam_above)
                worldsun.z = -worldsun.z;
            
            vec3 reflected_view = normalize((omw.viewMatrix * vec4(reflected, 0.0)).xyz);
            float water_incidence = abs(dot(view_ray, normal));
            //float water_incidence = max(0.0, -dot(view_ray, normal));
            float sun_incidence = dot(sun, reflected);
            float sun_angle = acos(sun_incidence);
            
            vec3 water_pos = mix(omw.eyePos.xyz, world_pos, water_distance/underwater_distance);
            
            float fog_amount = depthToFog(water_distance, normalize(view_ray_view));
            
            float broad = 0.2;
            
            //float hit_sun = sun_incidence - cos(0.5 * PI / 180.0);
            
            float hit_sun_main = getPBRSpecular(normal, -view_ray, sun, uSunRoughness);
            float hit_sun_glare = getPBRSpecular(normal, -view_ray, sun, 0.3);
            
            vec3 half_fog = mix(vec3(1.0, 1.0, 1.0), omw.fogColor.xyz, 0.75);
            
            vec3 water_color = pow(vec3(0.5, 0.8, 1.0)*omw.fogColor.xyz, vec3(gamma));
            
            // get reflected world color
            vec4 reflected_color = vec4(0.0);
            if(true)
            {
                RaymarchOutput data = raymarch(water_pos, water_distance, normal, reflected, res);
                reflected_color = data.color;
            }

            vec3 sky_color = fog_color*vec3(0.8, 1.0, 1.2);
            reflected_color.rgb = mix(sky_color, reflected_color.rgb, reflected_color.a);
            float reflected_amount = fresnelSchlick(water_incidence, 0.02, 1.0);
            
            vec3 distortion_color = base_color;
            float water_deepness = abs(underwater_distance - water_distance);
            if (uRefraction > 0.0)
            {
                // HACK: this should teeeeecccchhhnically be raymarching but it would be extra cost and the difference doesn't really matter
                float water_deepness_f = clamp(water_deepness/100.0, 0.0, 1.0) * uRefraction * 500.0;
                vec2 distortion_coord = omw_TexCoord + water_deepness_f * normal.xy * res;
                float distortion_deepness = omw_GetLinearDepth(distortion_coord) - water_distance;
                if(distortion_deepness > 0.0)
                {
                    distortion_color = pow(omw_GetLastShader(distortion_coord).rgb, vec3(uGamma));
                    water_deepness = distortion_deepness;
                }
                
            }
            if (cam_above && uUnderwaterFog)
            {
                vec3 sky_compressed = pow(fog_color, vec3(gamma));
                float sky_brightness = dot(sky_compressed, vec3(1.0/3.0));
                vec3 ambient_sky_filtering_guess = mix(sky_compressed, vec3(sky_brightness), 1.0);
                vec3 water_fog_color = pow(vec3(0.5, 0.5, 0.5), vec3(gamma)) * ambient_color * ambient_sky_filtering_guess;
                float distortion_fog_amount = 1.0 - exp(water_deepness/view_ray_view.z * 0.001);
                distortion_fog_amount *= 1.0 - fog_amount;
                distortion_color = mix(distortion_color, water_fog_color, distortion_fog_amount);
            }
            
            
            float distortion_amount = (1.0 - reflected_amount);
            float water_fraction = pow(0.05, mix(gamma, 1.0, 0.5)) * (1.0 - fog_amount);
            float water_amount = distortion_amount * water_fraction;
            distortion_amount *= 1.0 - water_fraction;
            

            if (uDemoHack > 0.5)
            {
                float amount = uDemoHack*2.0-1.0;
                reflected_amount = mix(reflected_amount, 1.0, amount);
                distortion_amount *= 1.0 - amount;
            }
            else if (uDemoHack < 0.5)
            {
                float amount = 1.0 - uDemoHack*2.0;
                distortion_amount = mix(distortion_amount, 1.0, amount);
                reflected_amount *= 1.0 - amount;
            }
            
            // mix fog in gamma-compressed light
            water_color = pow(mix(pow(water_color, vec3(1.0/gamma)), fog_color_raw, fog_amount), vec3(gamma));
            
            vec3 mixed_color =
                distortion_color * distortion_amount * vec3(0.4,0.5,0.6)
              + reflected_color.rgb * reflected_amount
              + water_color * water_amount;

            // FOR DEBUGGING: set to 0.0 to view reflections 1:1
            filter_amount *= (1.0-fog_amount);

            //mixed_color *= 0.0;
            
            if (uSunBrightness > 0.0)
            {
                mixed_color += filter_amount * sun_color * hit_sun_main  * mix(0.1, 1.0, sunvis) * uSunBrightness;
                mixed_color += filter_amount * sun_color * hit_sun_glare * mix(0.1, 1.0, sunvis) * uSunBrightness * 0.001;
            }
            
            base_color = mixed_color;
        }
        base_color = pow(base_color, vec3(1.0/gamma));
        omw_FragColor.rgb = base_color;
    }
}

technique {
    passes = main;
    description = "sghtrhjt";
    author = "asdf";
    version = "0.1";
}
